
float fbm2(point pp,float freq,float ampl,float high_freq_multiplier)
{
		float n2= noise("perlin",pp*freq ) * ampl ;
	float n3= noise("perlin",pp*freq*high_freq_multiplier ) * ampl/high_freq_multiplier ;
	return  n2 + n3;
	
}
	
shader 
flow_color
(
		float shader_property_0 = 0 
		[[ int lockgeom = 0 ]],
			float shader_property_1 = 0 
		[[ int lockgeom = 0 ]],
			float shader_property_2 = 0 
		[[ int lockgeom = 0 ]],
		 point Pobj = 0 
         [[
         int lockgeom = 0
         ]],
vector temp = vector(1,0,0),

	color base_color = color(0.292,0.211,0.137),
	color second_color = color(0.292/10,0.211/10,0.137/10),
float blur = 0.001,
float  center = 0,
output float resultF = 0,
   output color resultRGB = 0

)	
{
	point pp = Pobj;
	point tpp;
	vector victor = vector(shader_property_0,shader_property_1,shader_property_2);
	normal dir_normalized = normalize(victor);
	tpp[0] = dir_normalized[0] * pp[0];
	tpp[1] = dir_normalized[1] * pp[1];
	tpp[2] = dir_normalized[2] * pp[2];
	float k = tpp[0] + tpp[1]+tpp[2];
	float scale_displ = 10;//0.05;
	float width_displ = scale_displ/10;//0.03;
	float scale_col = 10;//0.005;
	float width_col = scale_col/10;//0.01;
	float cent_displ = scale_displ*round(   k /scale_displ);
	float cent_col =   scale_col*round(   k /scale_col);
	 //+ 0.01*fbm2(tpp,40,5,5);

	//float k_displ   = (noise("perlin",10*tpp)*0.01 + k);
	//float k_col     = (noise("perlin",130*tpp)*0.01 + k);
	float blend_displ = smoothstep(  cent_displ - width_displ, cent_displ, k) * (1 - smoothstep(cent_displ , cent_displ+ width_displ, k));
	float blend_col   = smoothstep(  cent_col - width_col, cent_col, k) * (1 - smoothstep(cent_col , cent_col+ width_col, k));	
	blend_displ       = blend_displ * (1-smoothstep (cent_displ,cent_displ +width_displ,k) );
	resultRGB         = mix(base_color,second_color,blend_col);
	blend_displ       += fbm2(tpp,70,3,5)*.1;
	resultF           = blend_displ*0.01;
	
}
