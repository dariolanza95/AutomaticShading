/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2019 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "RixPattern.h"
#include "RixShadingUtils.h"

class PxrMix : public RixPattern
{
public:

    PxrMix();
    virtual ~PxrMix();

    virtual int Init(RixContext &, RtUString const pluginpath) override;
    virtual RixSCParamInfo const *GetParamTable() override;
    virtual void Synchronize(
        RixContext&,
        RixSCSyncMsg,
        RixParameterList const*) override
    {
    }

    virtual void Finalize(RixContext &) override;

    virtual int ComputeOutputParams(RixShadingContext const *,
                                    RtInt *n, RixPattern::OutputSpec **outputs,
                                    RtPointer instanceData,
                                    RixSCParamInfo const *) override;

    virtual bool Bake2dOutput(
        RixBakeContext const*,
        Bake2dSpec&,
        RtPointer) override
    {
        return false;
    }

    virtual bool Bake3dOutput(
        RixBakeContext const*,
        Bake3dSpec&,
        RtPointer) override
    {
        return false;
    }

private:
    // Defaults
    RtColorRGB const m_color1;
    RtColorRGB const m_color2;
    RtFloat const m_mix;
    RtInt const m_clampMix;
};

PxrMix::PxrMix() :
    m_color1(0.f, 0.f, 0.f),
    m_color2(1.f, 1.f, 1.f),
    m_mix(0.f),
    m_clampMix(0)
{
}

PxrMix::~PxrMix()
{
}

int
PxrMix::Init(RixContext &ctx, RtUString const pluginpath)
{
    PIXAR_ARGUSED(ctx);
    PIXAR_ARGUSED(pluginpath);

    return 0;
}

enum paramId
{
    k_resultRGB=0,     // color output
    k_resultR,         // float output
    k_resultG,         // float output
    k_resultB,         // float output

    k_color1,
    k_color2,
    k_mix,
    k_clampMix,
    k_numParams
};

RixSCParamInfo const *
PxrMix::GetParamTable()
{
    static RixSCParamInfo s_ptable[] =
    {
        // outputs
        RixSCParamInfo(RtUString("resultRGB"), k_RixSCColor, k_RixSCOutput),
        RixSCParamInfo(RtUString("resultR"),  k_RixSCFloat, k_RixSCOutput),
        RixSCParamInfo(RtUString("resultG"),  k_RixSCFloat, k_RixSCOutput),
        RixSCParamInfo(RtUString("resultB"),  k_RixSCFloat, k_RixSCOutput),

        // inputs
        RixSCParamInfo(RtUString("color1"), k_RixSCColor),
        RixSCParamInfo(RtUString("color2"), k_RixSCColor),
        RixSCParamInfo(RtUString("mix"), k_RixSCFloat),
        RixSCParamInfo(RtUString("clampMix"), k_RixSCInteger),

        RixSCParamInfo() // end of table
    };
    return &s_ptable[0];
}

void
PxrMix::Finalize(RixContext &ctx)
{
    PIXAR_ARGUSED(ctx);
}

enum mixResult
{
    k_resultMixed,
    k_resultColor1,
    k_resultColor2
};

int
PxrMix::ComputeOutputParams(RixShadingContext const *sctx,
                                RtInt *noutputs, OutputSpec **outputs,
                                RtPointer instanceData,
                                RixSCParamInfo const *ignored)
{
    PIXAR_ARGUSED(instanceData);
    PIXAR_ARGUSED(ignored);

    bool varying = true;
    RixSCType type;
    RixSCConnectionInfo cinfo;

    // Find the number of outputs
    RixSCParamInfo const* paramTable = GetParamTable();
    int numOutputs = -1;
    while (paramTable[++numOutputs].access == k_RixSCOutput) {}

    // Allocate and bind our outputs
    RixShadingContext::Allocator pool(sctx);
    OutputSpec* out = pool.AllocForPattern<OutputSpec>(numOutputs);
    *outputs = out;
    *noutputs = numOutputs;

    // looping through the different output ids
    for (int i = 0; i < numOutputs; ++i)
    {
        out[i].paramId = i;
        out[i].detail = k_RixSCInvalidDetail;
        out[i].value = NULL;

        type = paramTable[i].type;    // we know this
        sctx->GetParamInfo(i, &type, &cinfo);
        if(cinfo == k_RixSCNetworkValue)
        {
            if( type == k_RixSCColor )
            {
                out[i].detail = k_RixSCVarying;
                out[i].value = pool.AllocForPattern<RtColorRGB>(sctx->numPts);
            }
            else if( type == k_RixSCFloat )
            {
                out[i].detail = k_RixSCVarying;
                out[i].value = pool.AllocForPattern<RtFloat>(sctx->numPts);
            }
        }
    }

    RtColorRGB* resultRGB = (RtColorRGB*) out[k_resultRGB].value;
    if(!resultRGB)
    {
        resultRGB = pool.AllocForPattern<RtColorRGB>(sctx->numPts);
    }
    RtFloat* resultR = (RtFloat*) out[k_resultR].value;
    RtFloat* resultG = (RtFloat*) out[k_resultG].value;
    RtFloat* resultB = (RtFloat*) out[k_resultB].value;

    // read the inputs
    RtFloat const *mix;
    RtColorRGB const *color1;
    RtColorRGB const *color2;

    int resultType = k_resultMixed;

    sctx->EvalParam(k_mix, -1, &mix, &m_mix, varying);
    sctx->GetParamInfo(k_mix, &type, &cinfo);
    if(cinfo != k_RixSCNetworkValue && (mix[0] == 0.f || mix[0] == 1.f))
    {
        // nothing is connected to mix, so we can assume it has
        // a constant value. Then we can check if the mix value
        // is 0 or 1 so that we only have to evaluate 1 input param.
        if(mix[0] == 1.f)
        {
            sctx->EvalParam(k_color2, -1, &color2, &m_color2, varying);
            resultType = k_resultColor2;
        }
        else // (mix[0] == 0.f)
        {
            sctx->EvalParam(k_color1, -1, &color1, &m_color1, varying);
            resultType = k_resultColor1;
        }
    }
    else
    {
        sctx->EvalParam(k_color1, -1, &color1, &m_color1, varying);
        sctx->EvalParam(k_color2, -1, &color2, &m_color2, varying);
        resultType = k_resultMixed;
    }
    RtInt const *clampMix;
    sctx->EvalParam(k_clampMix, -1, &clampMix, &m_clampMix, !varying);

    for (int i = 0; i < sctx->numPts; ++i)
    {
        if(resultType == k_resultMixed)
        {
            resultRGB[i] = RixMix(color1[i], color2[i],
                                  clampMix[0]? RixClamp(mix[i], 0.f, 1.f): mix[i]);
        }
        else if(resultType == k_resultColor1)
        {
            resultRGB[i] = color1[i];
        }
        else // resultType == k_resultColor2
        {
            resultRGB[i] = color2[i];
        }

        if(resultR)
        {
            resultR[i] = resultRGB[i].r;
        }
        if(resultG)
        {
            resultG[i] = resultRGB[i].g;
        }
        if(resultB)
        {
            resultB[i] = resultRGB[i].b;
        }
    }

    return 0;
}

RIX_PATTERNCREATE
{
    PIXAR_ARGUSED(hint);

    return new PxrMix();
}


RIX_PATTERNDESTROY
{
    delete ((PxrMix*)pattern);
}
