
float createRing(vector direction,point pp,float s_min,float s_max, float freq,float ampl,float noise_stregth,float blur)
{
	point tpp;
	float high_freq_multiplier = 3 ;
	normal dir_normalized = normalize(direction);
	tpp[0] = dir_normalized[0] * pp[0];
	tpp[1] = dir_normalized[1] * pp[1];
	tpp[2] = dir_normalized[2] * pp[2];
	float k = tpp[0] + tpp[1]+tpp[2];
	float n2= noise("perlin",pp*freq ) * ampl ;
	float n3= noise("perlin",pp*freq*high_freq_multiplier ) * ampl/high_freq_multiplier ;
	float n = n2 + n3;
	k = k + n* noise_stregth;
	float blend = smoothstep(s_min, s_min + blur, k) *
                (1 - smoothstep(s_max - blur, s_max, k));
return blend;

}



float createCuttingPlane(vector direction,point pp,float s_min,float s_max, float freq,float ampl,float noise_stregth,float blur)
{
	point tpp;
	float high_freq_multiplier = 3 ;
	normal dir_normalized = normalize(direction);
	tpp[0] = dir_normalized[0] * pp[0];
	tpp[1] = dir_normalized[1] * pp[1];
	tpp[2] = dir_normalized[2] * pp[2];
	float k = tpp[0] + tpp[1]+tpp[2];
	float n2= noise("perlin",pp*freq ) * ampl ;
	float n3= noise("perlin",pp*freq*high_freq_multiplier ) * ampl/high_freq_multiplier ;
	float n = n2 + n3;
	
	float n4 = noise("perlin",pp*15);
	float n5 = noise("perlin",pp*15)*1/25;
	k = k + n* noise_stregth;
	float blend = ( smoothstep(s_max - blur, s_max, k));
	pp = pp*16;
	//float fbm = noise("perlin",4*pp)*1/4 + noise("perlin",8*pp)*1/8 + noise("perlin",16*pp)*1/16;
//	blend= blend*0.6 + 0.4*fbm;
return blend;

}



shader 
test05
(float  minheight = 1.25,
         float  maxheight = 2.5,
vector direction = vector(1,0,0),
int details = 1,
int medium_details = 2,
		float s = 0 [[int lockgeom = 0]],
        float t = 0 [[int lockgeom = 0]],	 
		 point Pobj = 0 
         [[
         int lockgeom = 0
         ]],
		 point Nobj = 0 
         [[
         int lockgeom = 0
         ]],
int scale = 1,
		 int level_of_details = 4,
	        
 color  mincolor = color(1,0,0),
         color  maxcolor = color(0,1,0),
		output float resultDispl = 0,
         output color resultRGB = 0,
output float resultF = 0)
{
point pp = Pobj;
//transform("object","world",Pobj) ;
point tpp;

normal dir_normalized = normalize(direction);
tpp[0] = dir_normalized[0] * pp[0];
tpp[1] = dir_normalized[1] * pp[1];
tpp[2] = dir_normalized[2] * pp[2];

float ampl = 0.8;
//the freq should be used to set how much "jaggied or scrumbled the surf will be"
float freq = 3.2;
float high_freq_multiplier = 5;

float step_increase = 0.1;
float s_min =0.1;
float s_max = s_min + step_increase;
float k = tpp[0] + tpp[1]+tpp[2];
step_increase = 0.12;
float offset = 0.01;
int i = 0;
float blend = 0;
float blur = 0.01;
//put it close to zero make more straight lines
float noise_strength = 0.1;
float minor_rings_offset= 0.01;
float minor_rings = 0;
float res = 0;
float temp = 0;
float s_min2 = 0;
float s_max2 = 0;
float randomness = 0.1;
for(i = 0;i<details;i++)
{
s_min += step_increase*i; 
s_max += step_increase*i;

blend = createRing(direction,pp,s_min,s_max,freq,ampl,noise_strength,blur);
temp = blend;
temp = 0;
for ( i = 0; i < medium_details;i++)
{ 
float rand0 = noise("perlin",pp + i * 1.414);
float rand1 = noise("perlin",pp + i * 42);
float rand2 = noise("perlin",pp + i * 3.14);

vector random_direction = vector(dir_normalized[0]+rand0*0.1,dir_normalized[1]+rand1*0.1,dir_normalized[2]+rand2*0.1);
normal random_normal = normalize(random_direction);
s_max2 = s_max +  minor_rings_offset*((i*0.8/medium_details)+0.1);
//s_min2 = s_min +  minor_rings_offset*((i*0.8/medium_details)+0.1) ;
minor_rings = createCuttingPlane( random_normal, point(pp[0] + rand0*randomness,pp[1] + rand1*randomness,pp[2] + rand2*randomness) ,s_min2, s_max2,15, 0.4,noise_strength, blur);

temp = max(temp , minor_rings * ((i*0.8/medium_details)+0.1) );


temp = clamp ( temp,0, 1);
//temp = minor_rings *((i*0.8/medium_details)+0.1);


}




	
//temp = 1-temp;
//blend = min(blend,temp);
//temp = clamp ( temp,0, 1);
res += temp;

/*
float n2= noise("perlin",pp*freq ) * ampl ;
float n3= noise("perlin",pp*freq*high_freq_multiplier ) * ampl/high_freq_multiplier ;
float n = n2 + n3;
k = k + n*0.1;


s_min += i*(0.11+offset);
s_max += i*(0.11+offset);
 blend += smoothstep(s_min, s_min + blur, k) *
                (1 - smoothstep(s_max - blur, s_max, k));
*/

}
float cellfreq = scale;

point thiscell = point(    trunc(pp[0]*cellfreq) + offset,
                           trunc(pp[1]*cellfreq) + offset,
                           trunc(pp[2]*cellfreq) + offset);

float cellnumber = noise("cell",scale*pp  );

float rand1 = noise("simplex",0.25*Pobj );
rand1 = noise("simplex",rand1);
resultF = 0.5*res;
resultRGB = color(0.5*res  );
}


