float SmallSizedRock(point Pobj,float scale)
{
	
	float n1= noise("perlin",scale*Pobj);		
	float n2= noise("perlin",scale*4*Pobj);
	n1 = smoothstep(0.1,0.2,n1);
	n2 = smoothstep(0.1,0.6,n2);
	//n3 = n3<0.5? 0 : 1;
	return  n1*n2;
}
float MediumSizedRock(point pp,float scale,float high_freq_multiplier)
{
float low_freq_noise = noise("perlin",scale*pp);
float high_freq_noise = noise("perlin",high_freq_multiplier*scale*pp);
float mask =max(low_freq_noise , high_freq_noise);
return mask ;

}

float BigSizedRockShape(point pp,float scale)
{
	float fbm = noise("perlin",2*pp)*1/2 + noise("perlin",4*pp)*1/4 ;
	return 0.1+ noise("perlin",4*pp)*1/12   ;
}


float BigSizedRockDistribuition (point pp,float scale)
{
	float n = noise("perlin",scale*pp);
	return smoothstep(n,n+0.45,0.5);
}


shader 
rockExfoliationColor
(
		 point Pobj = 0 
         [[
         int lockgeom = 0
         ]],
		 point Nobj = 0 
         [[
         int lockgeom = 0
         ]],
		float scale = 1,
		color basecolor = color(0,0,0),
		color secondcolor = color(0,0,0),
 		output color resultRGB = 0,
output float resultDispl= 0

)
{	
 
	point pp = Pobj;
	//pp = transform("world", P);	
	
	//Check the node : should give shading normal (Nn) in object space, check type as well (normal);
	normal nn = transform("world",Nobj);
	float n1= noise("perlin",scale*Pobj);
	float n2 =  noise("perlin",13*Pobj);
	float high_freq_scale = 3;
	float high_freq_noise = noise("perlin",high_freq_scale*scale*pp);
	float mask = max(n1 , high_freq_noise);
	point p1 = point ("world",0,0,0);
	float n = 0;
	int i=0;
	int medium_sized_rocks_amount = 1;
	int small_sized_rocks_amount = 5;
	//from [1,10] this gives us alot of pretty small rocks (10 almost covers everything and 1 is too few)
	float random_offset = 4.2;
	for (i=0;i<small_sized_rocks_amount;i++)
	{
		 n += SmallSizedRock(pp+i * random_offset,2*i);
	//float n3 = dust(pp+42,5);
	
	}
	random_offset = 6.6267;
	float blend = 0; 

	
	//n= n+n3;
//	point scalevector = (pp-p1);
	//vector scalevector = vector(1,1,-3);
	vector scalevector = nn;
	
	float scalex = scalevector[0];
	float scaley = scalevector[1];
	float scalez = scalevector[2];
	point temp = point(pp[0],pp[1],pp[2]);
	matrix m = matrix(scalex,0,0,0,
					0,scaley,0,0,
					0,0,scalez,0,
					0,0,0,1	  );
	temp = transform(m,pp);				
	float fbm;
	
	blend = smoothstep(mask,mask+0.1, 0.5);
	float blend_displ=blend;

	//color secondcolorHSV = transformc ("hsv","rgb", secondcolor);
	//secondcolorHSV[2] =  clamp(secondcolorHSV[2]*1.5,0,1); 
	//secondcolorHSV[1] = clamp(secondcolorHSV[1]*1.5,0,1); 
	color oxidation = mix(secondcolor,color(1,1,1),0.05);
//	float blend2 = smoothstep(n,n+0.2,0.5);
	float blend2 = smoothstep(n,n+0.4,0.5);
	color black = color(0,0,0);
	color white= color(1,1,1);
	normal y = normal (0,1,0);
	color  oxidatedsecondcolor = mix(oxidation,secondcolor,blend2);
		color col = color(0,0,0);
		for ( i = 0;i< medium_sized_rocks_amount;i++)
	{
		mask =  MediumSizedRock(pp + i* random_offset,1,3);
		blend = smoothstep(mask,mask+0.1, 0.5);
		col = max(col,blend);
		blend_displ += blend;
	}
	
	color res = mix (basecolor,oxidatedsecondcolor,blend);
	resultRGB = res;

	//res = dot(nn,y) * res;
	//res = dot(nn,y) < 0.95 ? color(0.7,0.7,0.7) : res;
	//res = color(nn[0],nn[1],nn[2]);
	//res = oxidatedsecondcolor;
	
	float distr = BigSizedRockDistribuition(pp,1);
	distr = 1-distr;
	//color(0.3,0.215,0.152)
//	resultRGB = mix(res,basecolor ,distr) ;

	float dot_prod = dot(nn,y);

	
	float temp2 = mix(0,1,blend2);
/*	if(dot_prod <= 0.7)
		{
			blend_displ = blend_displ*dot_prod*noise("perlin",5*pp)*2;
		}
	*/
	temp2 = temp2*0.1;
	float temp3 =  mix(0,temp2,blend_displ);
	temp3 = 1 - temp3;
	fbm = noise("perlin",4*pp)*1/4 + noise("perlin",8*pp)*1/8 + noise("perlin",16*pp)*1/16;
	
	 distr = BigSizedRockDistribuition(pp,1);
	distr = 1-distr;
	distr *= BigSizedRockShape(pp,1);
	resultDispl = temp3*0.1 + fbm*0.1 ;//+ distr ;
	
	
		
//dot_prod*noise("perlin",5*pp)*2;
}
