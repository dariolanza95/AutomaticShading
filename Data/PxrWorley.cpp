/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2019 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#include "RixPredefinedStrings.hpp"
#include "RixPattern.h"
#include "RixShadingUtils.h"

class PxrWorley : public RixPattern
{
public:

    PxrWorley();
    virtual ~PxrWorley();

    virtual int Init(RixContext &, RtUString const pluginpath) override;
    virtual RixSCParamInfo const *GetParamTable() override;

    virtual void Synchronize(
        RixContext&,
        RixSCSyncMsg,
        RixParameterList const*) override
    {
    }

    virtual void Finalize(RixContext &) override;

    virtual int ComputeOutputParams(RixShadingContext const *,
                                    RtInt *noutputs,
                                    OutputSpec **outputs,
                                    RtPointer instanceData,
                                    RixSCParamInfo const *) override;

    virtual bool Bake2dOutput(
        RixBakeContext const*,
        Bake2dSpec&,
        RtPointer) override
    {
        return false;
    }

    virtual bool Bake3dOutput(
        RixBakeContext const*,
        Bake3dSpec&,
        RtPointer) override
    {
        return false;
    }

private:
    // Defaults
    RtInt const m_surfacePosition;
    RtFloat const m_frequency;
    RtInt const m_distancemetric;
    RtFloat const m_jitter;
    RtInt const m_clamp;
    RtFloat const m_c1;
    RtFloat const m_c2;
    RtFloat const m_minkowskiExp;
    RtInt const m_shape;
    RtFloat const m_randomScale;
    RtFloat const m_randomScaleCenter;
    RtInt const m_invert;
    RtColorRGB const m_colorScale;
    RtColorRGB const m_colorOffset;
    RtFloat const m_floatScale;
    RtFloat const m_floatOffset;
    RtPoint3 const m_defaultST;

    RixShadeFunctions *m_sFuncs;
};

PxrWorley::PxrWorley() :
    m_surfacePosition(0),
    m_frequency(4.0f),
    m_distancemetric(0),
    m_jitter(0.75f),
    m_clamp(1),
    m_c1(0.8f),
    m_c2(-0.2f),
    m_minkowskiExp(4.0f),
    m_shape(0),
    m_randomScale(0.0f),
    m_randomScaleCenter(0.0f),
    m_invert(0),
    m_colorScale(1.f, 1.f, 1.f),
    m_colorOffset(0.f, 0.f, 0.f),
    m_floatScale(1.f),
    m_floatOffset(0.f),
    m_defaultST(0.0f, 0.0f, 0.0f),
    m_sFuncs(NULL)
{
}

PxrWorley::~PxrWorley()
{
}

int
PxrWorley::Init(RixContext &ctx, RtUString const pluginpath)
{
    PIXAR_ARGUSED(pluginpath);

    m_sFuncs = (RixShadeFunctions*)ctx.GetRixInterface(k_RixShadeFunctions);
    if (!m_sFuncs)
        return 1;
    else
        return 0;
}

enum paramId
{
    k_resultF = 0,
    k_resultRGB,
    k_surfacePosition,
    k_frequency,
    k_distancemetric,
    k_jitter,
    k_clamp,
    k_c1,
    k_c2,
    k_minkowskiExponent,
    k_shape,
    k_randomScale,
    k_randomScaleCenter,
    k_invert,
    k_colorScale,
    k_colorOffset,
    k_floatScale,
    k_floatOffset,
    k_manifold,
    k_manifoldQ,
    k_manifoldQradius,
    k_manifoldEnd
};

enum distanceMetric
{
    k_euclidean,
    k_euclideanSquared,
    k_manhattan,
    k_chebyshev,
    k_minkowski
};

enum cellShape
{
    k_linear = 0,
    k_thin,
    k_fat
};

enum surfPos
{
    k_useP = 0,
    k_usePo
};

RixSCParamInfo const *
PxrWorley::GetParamTable()
{
    static RixSCParamInfo s_ptable[] =
    {
        RixSCParamInfo(RtUString("resultF"), k_RixSCFloat, k_RixSCOutput),
        RixSCParamInfo(RtUString("resultRGB"), k_RixSCColor, k_RixSCOutput),
        RixSCParamInfo(RtUString("surfacePosition"), k_RixSCInteger),
        RixSCParamInfo(RtUString("frequency"), k_RixSCFloat),
        RixSCParamInfo(RtUString("distancemetric"), k_RixSCInteger),
        RixSCParamInfo(RtUString("jitter"), k_RixSCFloat),
        RixSCParamInfo(RtUString("clamp"), k_RixSCInteger),
        RixSCParamInfo(RtUString("c1"), k_RixSCFloat),
        RixSCParamInfo(RtUString("c2"), k_RixSCFloat),
        RixSCParamInfo(RtUString("minkowskiExponent"), k_RixSCFloat),
        RixSCParamInfo(RtUString("shape"), k_RixSCInteger),
        RixSCParamInfo(RtUString("randomScale"), k_RixSCFloat),
        RixSCParamInfo(RtUString("randomScaleCenter"), k_RixSCFloat),
        RixSCParamInfo(RtUString("invert"), k_RixSCInteger),

        RixSCParamInfo(RtUString("colorScale"), k_RixSCColor),
        RixSCParamInfo(RtUString("colorOffset"), k_RixSCColor),
        RixSCParamInfo(RtUString("floatScale"), k_RixSCFloat),
        RixSCParamInfo(RtUString("floatOffset"), k_RixSCFloat),

        RixSCParamInfo(RtUString("PxrManifold"), RtUString("manifold"), k_RixSCStructBegin),
        RixSCParamInfo(RtUString("Q"), k_RixSCPoint),
        RixSCParamInfo(RtUString("Qradius"), k_RixSCFloat),
        RixSCParamInfo(RtUString("PxrManifold"), RtUString("manifold"), k_RixSCStructEnd),
        RixSCParamInfo() // end of table
    };
    return &s_ptable[0];
}

void
PxrWorley::Finalize(RixContext &ctx)
{
    PIXAR_ARGUSED(ctx);
}


int
PxrWorley::ComputeOutputParams(RixShadingContext const *sctx,
                               RtInt *noutputs, OutputSpec **outputs,
                               RtPointer instanceData,
                               RixSCParamInfo const *ignored)
{
    PIXAR_ARGUSED(instanceData);
    PIXAR_ARGUSED(ignored);

    bool varying = true;
    bool uniform = false;

    RtInt const *surfacePosition;
    sctx->EvalParam(k_surfacePosition, -1, &surfacePosition,
                    &m_surfacePosition, uniform);

    RtFloat const *frequency;
    sctx->EvalParam(k_frequency, -1, &frequency, &m_frequency, varying);

    RtInt const *distancemetricp;
    sctx->EvalParam(k_distancemetric, -1, &distancemetricp,
                    &m_distancemetric, uniform);
    RtInt const distancemetric(*distancemetricp);

    RtFloat const *jitter;
    sctx->EvalParam(k_jitter, -1, &jitter, &m_jitter, varying);

    RtInt const *clampPtr;
    sctx->EvalParam(k_clamp, -1, &clampPtr, &m_clamp, uniform);
    RtInt const clamp(*clampPtr);

    RtFloat const *c1;
    sctx->EvalParam(k_c1, -1, &c1, &m_c1, varying);

    RtFloat const *c2;
    sctx->EvalParam(k_c2, -1, &c2, &m_c2, varying);

    RtFloat const *minkowskiExpPtr;
    sctx->EvalParam(k_minkowskiExponent, -1, &minkowskiExpPtr,
                    &m_minkowskiExp, uniform);
    RtFloat const minkowskiExp(RixMax(0.5f, *minkowskiExpPtr));

    RtInt const *shapePtr;
    sctx->EvalParam(k_shape, -1, &shapePtr, &m_shape, uniform);
    RtInt const shape(*shapePtr);

    RtFloat const *randomScale;
    sctx->EvalParam(k_randomScale, -1, &randomScale, &m_randomScale,
                    varying);

    RtFloat const *randomScaleCenter;
    sctx->EvalParam(k_randomScaleCenter, -1, &randomScaleCenter,
                    &m_randomScaleCenter, varying);

    RtInt const *invertPtr;
    sctx->EvalParam(k_invert, -1, &invertPtr, &m_invert, uniform);
    RtInt const invert(*invertPtr);

    RtColorRGB const *colorScale;
    sctx->EvalParam(k_colorScale, -1, &colorScale, &m_colorScale, true);
    RtColorRGB const *colorOffset;
    sctx->EvalParam(k_colorOffset, -1, &colorOffset, &m_colorOffset, true);
    RtFloat const *floatScale;
    sctx->EvalParam(k_floatScale, -1, &floatScale, &m_floatScale, true);
    RtFloat const *floatOffset;
    sctx->EvalParam(k_floatOffset, -1, &floatOffset, &m_floatOffset, true);

    // Allocate and bind our outputs
    RixShadingContext::Allocator pool(sctx);
    OutputSpec *o = pool.AllocForPattern<OutputSpec>(2);
    *outputs = o;
    *noutputs = 2;

    RtFloat *resultF = NULL;
    resultF = pool.AllocForPattern<RtFloat>(sctx->numPts);
    o[0].paramId = k_resultF;
    o[0].detail  = k_RixSCVarying;
    o[0].value = (RtPointer) resultF;

    RtColorRGB *resultRGB = NULL;
    resultRGB = pool.AllocForPattern<RtColorRGB>(sctx->numPts);
    o[1].paramId = k_resultRGB;
    o[1].detail  = k_RixSCVarying;
    o[1].value = (RtPointer) resultRGB;

    // check for manifold input
    RixSCType type;
    RixSCConnectionInfo cinfo;

    RtPoint3 *sP;
    sctx->GetParamInfo(k_manifold, &type, &cinfo);
    if (cinfo != k_RixSCNetworkValue)
    {
        // We want P by default (not st)
        RtPoint3 const *Q;
        if (*surfacePosition == k_usePo)
            sctx->GetBuiltinVar(RixShadingContext::k_Po, &Q);
        else
            sctx->GetBuiltinVar(RixShadingContext::k_P, &Q);

        sP = pool.AllocForPattern<RtPoint3>(sctx->numPts);
        memcpy(sP, Q, sizeof(RtPoint3)*sctx->numPts);

        // transform P in object space by default
        //
        sctx->Transform(RixShadingContext::k_AsPoints,
                        Rix::k_current, Rix::k_object, sP, NULL);
    }
    else
    {
        RtPoint3 const *mQ;
        sctx->EvalParam(k_manifoldQ, -1, &mQ, &m_defaultST, true);
        sP = const_cast<RtPoint3*>(mQ);
    }

    RtPoint3 f1cell, f2cell;
    for (int n = 0; n < sctx->numPts; ++n)
    {
        float f1,f2,d;
        RtPoint3 pp = frequency[n] * sP[n];
        RtPoint3 thiscell = RtPoint3 (floorf(pp.x)+0.5f,
                                      floorf(pp.y)+0.5f,
                                      floorf(pp.z)+0.5f);
        f1 = f2 = 1000.0f;
        for (int i = -1;  i <= 1;  i += 1)
        {
            for (int j = -1;  j <= 1;  j += 1)
            {
                for (int k = -1;  k <= 1;  k += 1)
                {
                    RtPoint3 testcell = thiscell + RtVector3(i,j,k);
                    RtPoint3 pos = testcell + jitter[n] *
                                   (RtVector3(m_sFuncs->CellNoise(testcell)) - 0.5f);
                    RtVector3 offset = pos - pp;
                    float dist;
                    switch (distancemetric)
                    {
                        case k_euclidean:
                            dist = sqrtf(Dot(offset, offset));
                            break;
                        case k_euclideanSquared:
                            dist = Dot(offset, offset);
                            break;
                        case k_manhattan:
                            dist =  fabsf(offset.x) +
                                    fabsf(offset.y) +
                                    fabsf(offset.z);
                            break;
                        case k_chebyshev:
                            offset.x = fabsf(offset.x);
                            offset.y = fabsf(offset.y);
                            offset.z = fabsf(offset.z);
                            d = (offset.x>offset.y)? offset.x:offset.y;
                            dist = (offset.z>d)? offset.z:d;
                            break;
                        case k_minkowski:
                            dist = powf(powf(fabsf(offset.x), minkowskiExp)+
                                        powf(fabsf(offset.y), minkowskiExp)+
                                        powf(fabsf(offset.z), minkowskiExp),
                                        1.0f/minkowskiExp);
                            break;
                        default:
                            dist = Dot(offset, offset);
                            break;
                    }

                    if (dist < f1)
                    {
                        f2 = f1;
                        f1 = dist;
                        f2cell = f1cell;
                        f1cell = pos;
                    }
                    else if (dist < f2)
                    {
                        f2 = dist;
                        f2cell = pos;
                    }
                }
            }
        }

        if (shape == k_thin)
        {
            f1 = sqrtf(f1);
            f2 = sqrtf(f2);
        }
        else if (shape == k_fat)
        {
            f1 = f1*f1;
            f2 = f2*f2;
        }

        // combine distances to create the pattern
        //
        resultF[n] = f2 * c2[n] + f1 * c1[n];

        // post-process
        //
        if (clamp != 0)
        {
            resultF[n] = RixClamp(resultF[n], 0.0f, 1.0f);
        }

        if (invert != 0)
        {
            resultF[n]= 1.f - resultF[n];
        }

        if (randomScale[n] != 0.f)
        {
            float mask = powf(f2-f1, 0.25f);
            mask = RixSmoothStep(randomScaleCenter[n], 1.f, mask);
            float scale = (m_sFuncs->CellNoise(f1cell) * mask);
            scale = (scale - randomScaleCenter[n]) * (1.f/(1.f - randomScaleCenter[n]));
            if (c1[n] != 0.f || c2[n] != 0.f)
                resultF[n] *= RixMix(1.f, scale, randomScale[n]);
            else
                resultF[n] = RixMix(0.f, scale, randomScale[n]);
        }

        resultRGB[n].r = resultRGB[n].g = resultRGB[n].b = resultF[n];
    }

    for (unsigned i=0; i<sctx->numPts; i++)
    {
        resultRGB[i] = resultRGB[i] * colorScale[i] + colorOffset[i];
        resultF[i] = resultF[i] * floatScale[i] + floatOffset[i];
    }

    return 0;
}

RIX_PATTERNCREATE
{
    PIXAR_ARGUSED(hint);

    return new PxrWorley();
}

RIX_PATTERNDESTROY
{
    delete ((PxrWorley*)pattern);
}

